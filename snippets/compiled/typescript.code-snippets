{
  "fgp_class": {
    "prefix": "fgp_class",
    "body": [
      "class $1 {",
      "    constructor(private $2: $3) {}",
      "  ",
      "    $4(): void {",
      "      console.log('$5');",
      "    }",
      "  }"
    ],
    "description": "fgp_class snippet"
  },
  "fgp_config_typeorm": {
    "prefix": "fgp_config_typeorm",
    "body": [
      "import { DataSource } from 'typeorm';",
      "import { EntityName } from './entity-name.entity';",
      "",
      "export const AppDataSource = new DataSource({",
      "  type: 'mysql',",
      "  host: 'localhost',",
      "  port: 3306,",
      "  username: 'root',",
      "  password: '',",
      "  database: 'my_database',",
      "  synchronize: true,",
      "  logging: false,",
      "  entities: [EntityName],",
      "  migrations: [],",
      "  subscribers: [],",
      "});",
      "",
      "AppDataSource.initialize()",
      "  .then(() => {",
      "    console.log('✅ Data Source has been initialized!');",
      "  })",
      "  .catch((err) => {",
      "    console.error('❌ Error during Data Source initialization:', err);",
      "  });"
    ],
    "description": "fgp_config_typeorm snippet"
  },
  "fgp_entity": {
    "prefix": "fgp_entity",
    "body": [
      "import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';",
      "",
      "@Entity()",
      "export class EntityName {",
      "  @PrimaryGeneratedColumn()",
      "  id: number;",
      "",
      "  @Column()",
      "  name: string;",
      "",
      "  @Column({ nullable: true })",
      "  description?: string;",
      "",
      "  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })",
      "  createdAt: Date;",
      "}"
    ],
    "description": "fgp_entity snippet"
  },
  "fgp_entity_controller": {
    "prefix": "fgp_entity_controller",
    "body": [
      "import { Request, Response } from \"express\";",
      "",
      "class $1Controller {",
      "  getAll(req: Request, res: Response) {",
      "    res.json({ message: \"Get all $1\" });",
      "  }",
      "",
      "  getById(req: Request, res: Response) {",
      "    const { id } = req.params;",
      "    res.json({ message: \"Get $1 by id\", id });",
      "  }",
      "",
      "  create(req: Request, res: Response) {",
      "    const data = req.body;",
      "    res.status(201).json({ message: \"Created $1\", data });",
      "  }",
      "",
      "  update(req: Request, res: Response) {",
      "    const { id } = req.params;",
      "    const data = req.body;",
      "    res.json({ message: \"Updated $1\", id, data });",
      "  }",
      "",
      "  remove(req: Request, res: Response) {",
      "    const { id } = req.params;",
      "    res.json({ message: \"Deleted $1\", id });",
      "  }",
      "}",
      "",
      "export default new $1Controller();"
    ],
    "description": "fgp_entity_controller snippet"
  },
  "fgp_entity_routes": {
    "prefix": "fgp_entity_routes",
    "body": [
      "import { Router } from 'express';",
      "const router = Router();",
      "import * as $1Controller from '../controllers/$1Controller';",
      "",
      "router.get('/', $1Controller.getAll);",
      "router.get('/:id', $1Controller.getById);",
      "router.post('/', $1Controller.create);",
      "router.put('/:id', $1Controller.update);",
      "router.delete('/:id', $1Controller.remove);",
      "",
      "export default router;"
    ],
    "description": "fgp_entity_routes snippet"
  },
  "fgp_entity_service": {
    "prefix": "fgp_entity_service",
    "body": [
      "class $1Service {",
      "  findAll(): any[] {",
      "    return [",
      "      { id: 1, name: \"$1 A\" },",
      "      { id: 2, name: \"$1 B\" },",
      "    ];",
      "  }",
      "",
      "  findById(id: number): any {",
      "    return { id, name: `$1 ${id}` };",
      "  }",
      "",
      "  create(data: any): any {",
      "    return { id: Date.now(), ...data };",
      "  }",
      "",
      "  update(id: number, data: any): any {",
      "    return { id, ...data };",
      "  }",
      "",
      "  remove(id: number): any {",
      "    return { deleted: true, id };",
      "  }",
      "}",
      "",
      "export default new $1Service();"
    ],
    "description": "fgp_entity_service snippet"
  },
  "fgp_entity_service_typeorm": {
    "prefix": "fgp_entity_service_typeorm",
    "body": [
      "import { Repository } from \"typeorm\";",
      "import { InjectRepository } from \"@nestjs/typeorm\";",
      "import { Injectable } from \"@nestjs/common\";",
      "import { EntityName } from \"./entity-name.entity\";",
      "",
      "@Injectable()",
      "export class EntityNameService {",
      "  constructor(",
      "    @InjectRepository(EntityName)",
      "    private readonly entityRepository: Repository<EntityName>",
      "  ) {}",
      "",
      "  async findAll(): Promise<EntityName[]> {",
      "    return this.entityRepository.find();",
      "  }",
      "",
      "  async findOne(id: number): Promise<EntityName | null> {",
      "    return this.entityRepository.findOneBy({ id });",
      "  }",
      "",
      "  async create(data: Partial<EntityName>): Promise<EntityName> {",
      "    const entity = this.entityRepository.create(data);",
      "    return this.entityRepository.save(entity);",
      "  }",
      "",
      "  async update(id: number, data: Partial<EntityName>): Promise<EntityName> {",
      "    await this.entityRepository.update(id, data);",
      "    return this.findOne(id) as Promise<EntityName>;",
      "  }",
      "",
      "  async remove(id: number): Promise<void> {",
      "    await this.entityRepository.delete(id);",
      "  }",
      "}"
    ],
    "description": "fgp_entity_service_typeorm snippet"
  },
  "fgp_rn_usePushNotifications": {
    "prefix": "fgp_rn_usePushNotifications",
    "body": [
      "// hooks/usePushNotifications.ts",
      "",
      "import Constants from \"expo-constants\";",
      "import * as Device from \"expo-device\";",
      "import * as Notifications from \"expo-notifications\";",
      "import { router } from \"expo-router\";",
      "import { useEffect, useState } from \"react\";",
      "import React, { Platform } from \"react-native\";",
      "",
      "if (!(globalThis as any)._hasSetNotificationHandler) {",
      "  Notifications.setNotificationHandler({",
      "    handleNotification: async () => ({",
      "      shouldPlaySound: true,",
      "      shouldSetBadge: true,",
      "      shouldShowBanner: true,",
      "      shouldShowList: true,",
      "    }),",
      "  });",
      "}",
      "",
      "function handleRegistrationError(errorMessage: string) {",
      "  alert(errorMessage);",
      "  throw new Error(errorMessage);",
      "}",
      "",
      "async function registerForPushNotificationsAsync() {",
      "  if (Platform.OS === \"android\") {",
      "    await Notifications.setNotificationChannelAsync(\"default\", {",
      "      name: \"default\",",
      "      importance: Notifications.AndroidImportance.MAX,",
      "      vibrationPattern: [0, 250, 250, 250],",
      "      lightColor: \"#FF231F7C\",",
      "    });",
      "  }",
      "",
      "  if (Device.isDevice) {",
      "    const { status: existingStatus } = await Notifications.getPermissionsAsync();",
      "    let finalStatus = existingStatus;",
      "    if (existingStatus !== \"granted\") {",
      "      const { status } = await Notifications.requestPermissionsAsync();",
      "      finalStatus = status;",
      "    }",
      "    if (finalStatus !== \"granted\") {",
      "      handleRegistrationError(\"Permission not granted to get push token for push notification!\");",
      "      return;",
      "    }",
      "    const projectId = Constants?.expoConfig?.extra?.eas?.projectId ?? Constants?.easConfig?.projectId;",
      "    if (!projectId) {",
      "      handleRegistrationError(\"Project ID not found\");",
      "    }",
      "    try {",
      "      const pushTokenString = (",
      "        await Notifications.getExpoPushTokenAsync({",
      "          projectId,",
      "        })",
      "      ).data;",
      "      console.log(pushTokenString);",
      "      return pushTokenString;",
      "    } catch (e: unknown) {",
      "      handleRegistrationError(`${e}`);",
      "    }",
      "  } else {",
      "    handleRegistrationError(\"Must use physical device for push notifications\");",
      "  }",
      "}",
      "",
      "function redirect(notification: Notifications.Notification) {",
      "  const url: any = notification.request.content.data?.url;",
      "  if (url) {",
      "    router.push(url);",
      "  }",
      "}",
      "",
      "type PushData = Record<string, any>;",
      "",
      "export function usePushNotifications(",
      "  endpointUrl: string | null = null,",
      "  data: PushData = {},",
      "  authToken: string | null = null // token para Authorization Bearer",
      ") {",
      "  const [expoPushToken, setExpoPushToken] = useState<string | null>(null);",
      "",
      "  useEffect(() => {",
      "    registerForPushNotificationsAsync().then((token) => {",
      "      if (token) setExpoPushToken(token);",
      "    });",
      "",
      "    let handledNotificationId: string | null = null;",
      "",
      "    // Si la app se abrió por una notificación (estado quit → foreground)",
      "    Notifications.getLastNotificationResponseAsync().then((response) => {",
      "      if (response?.notification && response.notification.request.identifier !== handledNotificationId) {",
      "        handledNotificationId = response.notification.request.identifier;",
      "        redirect(response.notification);",
      "      }",
      "    });",
      "",
      "    // Escuchar interacciones en vivo (background → foreground o foreground)",
      "    const responseListener = Notifications.addNotificationResponseReceivedListener((response) => {",
      "      if (response.notification.request.identifier !== handledNotificationId) {",
      "        handledNotificationId = response.notification.request.identifier;",
      "        redirect(response.notification);",
      "      }",
      "    });",
      "",
      "    // Si quieres escuchar cuando llega una notificación mientras la app está abierta",
      "    const notificationListener = Notifications.addNotificationReceivedListener((notification) => {",
      "      // Aquí podrías mostrar algo en UI, guardar estado, etc.",
      "    });",
      "",
      "    return () => {",
      "      responseListener.remove();",
      "      notificationListener.remove();",
      "    };",
      "  }, []);",
      "",
      "  // Enviar token + data al endpoint cada vez que cambie el token o el objeto data",
      "  useEffect(() => {",
      "    if (expoPushToken && endpointUrl) {",
      "      const payload = { ...data, token: expoPushToken };",
      "      fetch(endpointUrl, {",
      "        method: \"POST\",",
      "        headers: {",
      "          \"Content-Type\": \"application/json\",",
      "          ...(authToken ? { Authorization: `Bearer ${authToken}` } : {}),",
      "        },",
      "        body: JSON.stringify(payload),",
      "      }).catch(console.error);",
      "    }",
      "  }, [expoPushToken, endpointUrl, data, authToken]);",
      "",
      "  return expoPushToken;",
      "}",
      "",
      "/* ",
      "",
      "// opción 1: sin parámetros",
      "  usePushNotifications();",
      "",
      "// opción 2: con endpoint y datos",
      "  const endpointUrl = \"http://192.168.18.21:3000/save-token\";",
      "  const data = { email: \"user123@gmail.com\" }; ",
      "  usePushNotifications(endpointUrl, data);",
      "",
      "// opción 3: con endpoint, datos y token de backend",
      "  const endpointUrl = \"http://192.168.18.21:3000/save-token\";",
      "  const data = { email: \"user123@gmail.com\", name: \"John Doe\" }; ",
      "  const backendToken = \"TU_TOKEN_DEL_BACKEND\";",
      "  usePushNotifications(endpointUrl, data, backendToken);",
      "",
      "",
      "",
      "# Notificaciones de la Expo (code example)",
      "https://docs.expo.dev/push-notifications/push-notifications-setup/",
      "https://docs.expo.dev/versions/latest/sdk/notifications/",
      "*/"
    ],
    "description": "fgp_rn_usePushNotifications snippet"
  }
}